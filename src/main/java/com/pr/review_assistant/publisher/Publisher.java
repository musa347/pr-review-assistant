package com.pr.review_assistant.publisher;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.pr.review_assistant.analysis.Finding;
import com.pr.review_assistant.database.ReviewJob;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.util.*;

@Slf4j
@Component
public class Publisher {

    private final RestTemplate restTemplate = new RestTemplate();

    @Value("${github.token}")
    private String githubToken;

    @Value("${github.api.url}")
    private String githubApiUrl;

    public void postResult(ReviewJob job, String formattedResults) {
        // Backward-compatible: only summary comment
        postResult(job, formattedResults, Collections.emptyList());
    }

    // New: summary + inline comments
    public void postResult(ReviewJob job, String formattedResults, List<com.pr.review_assistant.analysis.Finding> findings) {
        log.info("Publishing results for PR #{} on {}", job.getPrNumber(), job.getRepo());

        try {
            if (!"test-token".equals(githubToken)) {
                // 1) Post a summary comment in the conversation
                postCommentToPR(job, formattedResults);
                // 2) Post inline review comments on the Files changed tab
                postInlineReviewComments(job, findings);
            } else {
                log.info("Test mode - would post comment and inline review");
            }

        } catch (Exception e) {
            log.error("Failed to publish results for PR #{} on {}: {}",
                    job.getPrNumber(), job.getRepo(), e.getMessage(), e);
        }
    }

    // Keep the old method for backward compatibility if needed
    public void postResult(ReviewJob job, List<String> findings) {
        String legacyFormat = formatFindings(findings);
        postResult(job, legacyFormat, Collections.emptyList());
    }

    private String formatFindings(List<String> findings) {
        if (findings.isEmpty()) {
            return "Code Review Results\n\n" +
                    "No issues found! Great job!\n\n" +
                    "Your code looks clean and follows best practices! \n\n" +
                    "---\n" +
                    "Generated by PR Review Assistant";
        }

        StringBuilder comment = new StringBuilder();
        comment.append("Code Review Results** \n\n");
        comment.append("Found ").append(findings.size()).append(" issue(s) that need attention:\n\n");

        for (int i = 0; i < findings.size(); i++) {
            comment.append("Issue ").append(i + 1).append("\n\n");
            comment.append("```java\n");
            comment.append(findings.get(i));
            comment.append("\n```\n\n");
            comment.append("---\n\n");
        }

        comment.append("Next Steps:\n");
        comment.append("- Review each issue above\n");
        comment.append("- Fix the identified problems\n");
        comment.append("- Push your changes to update this PR\n\n");
        comment.append("---\n");
        comment.append("Generated by PR Review Assistant | ");
        comment.append("Analysis completed at: ").append(java.time.LocalDateTime.now().toString());

        return comment.toString();
    }

    private void postCommentToPR(ReviewJob job, String commentBody) {
        String url = String.format("%s/repos/%s/issues/%d/comments",
                githubApiUrl, job.getRepo(), job.getPrNumber());

        log.info("Posting summary comment to URL: {}", url);
        log.info("Comment body length: {} characters", commentBody.length());

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setBearerAuth(githubToken);

        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("body", commentBody);

        HttpEntity<Map<String, String>> request = new HttpEntity<>(requestBody, headers);

        try {
            ResponseEntity<String> response = restTemplate.postForEntity(url, request, String.class);

            if (response.getStatusCode().is2xxSuccessful()) {
                log.info("Successfully posted summary comment to PR #{} on {}", job.getPrNumber(), job.getRepo());
            } else {
                log.warn("Unexpected response when posting summary comment: {}", response.getStatusCode());
            }

        } catch (Exception e) {
            log.error("Failed to post summary comment to GitHub: {}", e.getMessage(), e);
            throw e;
        }
    }

    // --- Inline review comments on Files changed ---
    private void postInlineReviewComments(ReviewJob job, List<Finding> findings) {
        try {
            if (findings == null || findings.isEmpty()) {
                log.info("No findings to post inline");
                return;
            }

            // GitHub endpoint for PR review comments (inline on files changed)
            String commentsUrl = String.format("%s/repos/%s/pulls/%d/comments",
                    githubApiUrl, job.getRepo(), job.getPrNumber());

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.setBearerAuth(githubToken);

            int posted = 0;
            int limit = Math.min(50, findings.size()); // Safety cap to avoid flooding
            for (Finding f : findings) {
                if (posted >= limit) break;
                if (f.getRelativePath() == null || f.getRelativePath().isEmpty() || f.getLine() <= 0) continue;

                Map<String, Object> body = new HashMap<>();
                body.put("body", buildInlineBody(f));
                body.put("commit_id", job.getHeadSha());
                body.put("path", f.getRelativePath());
                body.put("side", "RIGHT");
                body.put("line", f.getLine());

                HttpEntity<Map<String, Object>> req = new HttpEntity<>(body, headers);
                try {
                    ResponseEntity<String> resp = restTemplate.postForEntity(commentsUrl, req, String.class);
                    if (resp.getStatusCode().is2xxSuccessful()) {
                        posted++;
                    } else {
                        log.debug("Inline comment failed for {}:{} -> {} {}", f.getRelativePath(), f.getLine(), resp.getStatusCode(), resp.getBody());
                    }
                } catch (Exception ex) {
                    log.debug("Inline comment exception for {}:{} -> {}", f.getRelativePath(), f.getLine(), ex.getMessage());
                }
            }

            log.info("Posted {} inline review comments", posted);
        } catch (Exception e) {
            log.warn("Posting inline review failed: {}", e.getMessage());
        }
    }

    private String buildInlineBody(Finding f) {
        StringBuilder sb = new StringBuilder();
        sb.append(f.getSeverity().toUpperCase()).append(": ").append(f.getRule()).append("\n\n");
        sb.append(f.getMessage());
        if (f.getSuggestion() != null && !f.getSuggestion().isEmpty()) {
            sb.append("\n\nSuggestion: ").append(f.getSuggestion());
        }
        return sb.toString();
    }
}
