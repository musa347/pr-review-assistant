package com.pr.review_assistant.analysis;

import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Component
public class FindingFormatter {
    
    public String FormatFindings(List<Finding> findings) {
        if (findings.isEmpty()) {
            return "Code Review Results\n\n" +
                   "**No issues found!** Your code looks clean and follows best practices!\n\n" +
                   "---\n" +
                   "*Generated by PR Review Assistant*";
        }
        
        StringBuilder comment = new StringBuilder();
        comment.append("Code Review Results\n\n");
        
        // Summary
        Map<String, Long> severityCounts = findings.stream()
                .collect(Collectors.groupingBy(Finding::getSeverity, Collectors.counting()));
        
        Map<String, Long> categoryCounts = findings.stream()
                .collect(Collectors.groupingBy(Finding::getCategory, Collectors.counting()));
        
        comment.append("**Summary:** Found ").append(findings.size()).append(" issue(s) that need attention\n\n");
        
        // Severity breakdown
        comment.append("Issue Breakdown\n");
        severityCounts.forEach((severity, count) -> {
            String emoji = getSeverityEmoji(severity);
            comment.append("- ").append(emoji).append(" **").append(severity).append("**: ").append(count).append(" issue(s)\n");
        });
        comment.append("\n");
        
        // Category breakdown
        comment.append("Categories\n");
        categoryCounts.forEach((category, count) -> {
            String emoji = getCategoryEmoji(category);
            comment.append("- ").append(emoji).append(" **").append(category).append("**: ").append(count).append(" issue(s)\n");
        });
        comment.append("\n");
        
        // Detailed findings
        comment.append("Detailed Issues\n\n");
        
        // Group by severity for better organization
        Map<String, List<Finding>> findingsBySeverity = findings.stream()
                .collect(Collectors.groupingBy(Finding::getSeverity));
        
        // Process in order: error, warning, info
        String[] severityOrder = {"error", "warning", "info"};
        
        for (String severity : severityOrder) {
            List<Finding> severityFindings = findingsBySeverity.get(severity);
            if (severityFindings != null && !severityFindings.isEmpty()) {
                comment.append("#### ").append(getSeverityEmoji(severity)).append(" ").append(severity.toUpperCase()).append(" Issues\n\n");
                
                for (int i = 0; i < severityFindings.size(); i++) {
                    Finding finding = severityFindings.get(i);
                    formatSingleFinding(comment, finding, i + 1);
                }
            }
        }
        
        // Action items
        comment.append("Next Steps\n\n");
        comment.append("1. **Review each issue above** - Focus on high-impact issues first\n");
        comment.append("2. **Apply the suggested fixes** - Each issue includes specific guidance\n");
        comment.append("3. **Test your changes** - Ensure fixes don't break existing functionality\n");
        comment.append("4. **Push your updates** - The review will automatically re-run\n\n");
        
        // Tips
        comment.append("Pro Tips\n\n");
        comment.append("- **High Impact** issues should be fixed first as they can cause bugs or maintenance problems\n");
        comment.append("- **Code Style** issues improve readability and team consistency\n");
        comment.append("- Consider using IDE auto-formatting and code analysis tools to catch these early\n\n");
        
        comment.append("---\n");
        comment.append("*Generated by PR Review Assistant | Analysis completed at: ").append(java.time.LocalDateTime.now().toString()).append("*");
        
        return comment.toString();
    }
    
    private void formatSingleFinding(StringBuilder comment, Finding finding, int index) {
        comment.append("<details>\n");
        comment.append("<summary>");
        comment.append("<strong>").append(finding.getFile()).append(":").append(finding.getLine());
        comment.append("</strong> - ").append(finding.getRule());
        comment.append(" ").append(getImpactBadge(finding.getImpact()));
        comment.append("</summary>\n\n");
        
        // Location info
        comment.append("Location: `").append(finding.getFile()).append("` line ").append(finding.getLine());
        if (finding.getColumn() > 0) {
            comment.append(", column ").append(finding.getColumn());
        }
        comment.append("\n\n");
        
        // Original message
        comment.append("Issue:").append(finding.getMessage()).append("\n\n");
        
        // Explanation
        if (finding.getExplanation() != null) {
            comment.append("Why this matters: ").append(finding.getExplanation()).append("\n\n");
        }
        
        // Suggestion
        if (finding.getSuggestion() != null) {
            comment.append("How to fix: ").append(finding.getSuggestion()).append("\n\n");
        }
        
        // Rule info
        comment.append("Category:** ").append(finding.getCategory()).append(" | ");
        comment.append("Impact: ").append(finding.getImpact()).append(" | ");
        comment.append("Rule: `").append(finding.getRule()).append("`\n\n");
        
        comment.append("</details>\n\n");
    }
    
    private String getSeverityEmoji(String severity) {
        switch (severity.toLowerCase()) {
            case "error": return "ğŸš¨";
            case "warning": return "âš ï¸";
            case "info": return "â„¹ï¸";
            default: return "ğŸ“";
        }
    }
    
    private String getCategoryEmoji(String category) {
        switch (category) {
            case "Code Safety": return "ğŸ›¡ï¸";
            case "Code Quality": return "â­";
            case "Code Style": return "ğŸ¨";
            case "Code Cleanliness": return "ğŸ§¹";
            case "Code Maintenance": return "ğŸ”§";
            default: return "ğŸ“‹";
        }
    }
    
    private String getImpactBadge(String impact) {
        switch (impact) {
            case "High": return "ğŸ”´";
            case "Medium": return "ğŸŸ¡";
            case "Low": return "ğŸŸ¢";
            default: return "âšª";
        }
    }
}